#lang racket

(provide expose-basic-blocks)

(module+ test
  (require rackunit))

(define l 0)
(define (newLabel)
  (set! l (add1 l))
  (format "L.tmp.~a" l))
(define (resetLabel)
  (set! l 0))

;
;(expose-begin e curLabel)->(list? list?) '(effect? ...) '(define ...)
;e: list? '(effect? ...)
;restP: tail?
;restD: list? '(define...)
(define (expose-begin e)
  (map (lambda (eff) (expose-effect eff)) e))

;
;(expose-if p l1 l2)->tail?/pred?/effect?
;p: tail?/pred?/effect?
;l1, l2: label?
(define (expose-if p l1 l2)
  #t)

;
;(expose-effect e)->(effect? list?) (curDefine  '(define ...))
;e: list? '(effect? ...)
(define (expose-effect e)
  (match e
    [`(set! ,a ,b) (values `((set! ,a ,b)) '())]
    [`(begin ,eff ...) '()]
    [`(if ,pred ,e1 ,e2) '()]
    [_ #f]))
    

;
;(expose-pred p curLabel)->(list? list?) '(e/p/t ....) (curDefine  '(define ...))
;p: pred?
(define (expose-pred-single p)
  (match p
    [`(,relop ,a ,b) `(,relop ,a ,b)]
    ['(true) '(true)]
    ['(false) '(false)]
    [_ #f]))


(define (expose-pred p curL1 curL2)
  (match p 
    [`(not ,pred) (match pred
                    [`(begin ,e ... ,pred) (expose-pred `(begin ,e ... (not ,pred)) curL1 curL2)]
                    [`(if ,p1 ,p2 ,p3) (expose-pred `(if (not ,p1) ,p2 ,p3) curL1 curL2)]
                    [,a `(not ,(expose-pred-single a))])]

    [`(begin ,e ... ,pred) (let-values ([(eP eD) (expose-begin e)]
                                        [(pP pD) (expose-pred pred l1 l2)])
                             (values (append eP pP)
                                     (append eD pD)))]
    [`(if ,p1 ,p2 ,p3) (let ([l1 (newLabel)]
                             [l2 (newLabel)])
                         (let-values ([(p1P p1D) (expose-pred p1 l1 l2)]
                                      [(p2P p2D) (expose-pred p2 curL1 curL2)]
                                      [(p3P p3D) (expose-pred p3 curL1 curL2)])
                           (values `(if ,p1P (jump ,l1) (jump ,l2))
                                   (append `((define ,l1 ,p2P)
                                             (define ,l2 ,p3P))
                                           p1D p2D p3D))))]
    
    

;
;(expose-tail t curLabel)->(tail? list?) (curDefine  '(define ...))
;t: tail?
(define (expose-tail t)
  (match t
    [`(halt ,a) (values `(halt ,a) '())]
    [`(begin ,e ... ,t) '()]
    [`(if ,pred ,t1 ,t2) (let ([l1 (newLabel)]
                               [l2 (newLabel)])
                           (let-values ([(pP pD) (expose-pred pred l1 l2)]
                                        [(t1P t1D) (expose-tail t1)]
                                        [(t2P t2D) (expose-tail t2)])
                             (values `(if pP (jump ,l1) (jump ,l2))
                                     (append `((define ,l1 ,t1P)
                                               (define ,l2 ,t2P))
                                             t1D t2D pD))))]
    [_ #f]))

;
;(expose-basic-blocks p)->Asm-lang-V4-nested
;p:Pred-lang-V4-Block
(define (expose-basic-blocks p)
  (println "begin")
  (println p)
  (println "start")
  (match p
    [`(module ,t) '()]
    [_ "blocks failed"]))

(module+ test
  (define (check-expose-func f a o m)
    (define-values (cp def) (f a))
    (resetLabel)
    (check-equal? cp (car o) m)
    (check-equal? def (second o) m))
  (define (check-expose p c m)
    (resetLabel)
    (check-equal? p c m))
                        
  #|
;expose-effect
  ;succes
  (check-expose-func expose-effect '(set! a0 (+ a1 a2)) '(((set! a0 (+ a1 a2))) ()) "expose-effect: succes-1: set instruction")
  
  (check-expose-func expose-effect '(begin (set! a0 (+ a1 a2))) '(((set! a0 (+ a1 a2))) ()) "expose-effect: succes-2: begin one effect")
  (check-expose-func expose-effect '(begin (set! a0 fv0) (set! a1 fv1) (set! a0 (+ a1 a0)) (set! fv0 a0))
                '(((set! a0 fv0) (set! a1 fv1) (set! a0 (+ a1 a0)) (set! fv0 a0)) ())
                "expose-effect: succes-3: begin multiple effects")
  (check-expose-func expose-effect '(begin (set! a0 fv0) (set! a1 fv1) (begin (set! a0 (+ a1 a0)) (set! a2 a0)) (set! fv0 a0))
                '(((set! a0 fv0) (set! a1 fv1) (set! a0 (+ a1 a0)) (set! a2 a0) (jump "L.tmp.1")) ((define "L.tmp.1" (begin (set! fv0 a0)))))
                "expose-effect: succes-4: nested begin")

  (check-expose-func expose-effect '(if (true) (set! a0 (+ a1 a2)) (set! a0 a1))
                     '(((if (true) (jump "L.tmp.1") (jump "L.tmp.2")))
                       ((define "L.tmp.1" (set! a0 (+ a1 a2))) (define "L.tmp.2" (set! a0 a1))))
                     "expose-effect: succes-05: if")

;expose-pred
  ;succes
  (check-expose-pred expose-pred '(= a0 a1) "L1" "L2" '((= a0 a1) ()) "expose-pred: succes-1: relop instruction")
  (check-expose-pred expose-pred '(true) "L1" "L2" '((true) ()) "expose-pred: succes-2: true")
  (check-expose-pred expose-pred '(false) "L1" "L2" '((false) ()) "expose-pred: succes-3: false")
  (check-expose-pred expose-pred '(not (true)) "L1" "L2" '((not (true)) ()) "expose-pred: succes-4: not instruction")
  (check-expose-pred expose-pred '(begin (= a0 a1)) "L1" "L2" '(((= a0 a1)) ()) "expose-pred: succes-5: begin one effect")
  (check-expose-pred expose-pred '(begin (set! a0 fv0) (set! a1 fv1) (begin (set! a0 (+ a1 a0)) (set! a2 a0)) (true))  "L1" "L2"
                '(((set! a0 fv0) (set! a1 fv1) (set! a0 (+ a1 a0)) (set! a2 a0) (jump "L.tmp.1")) ((define "L.tmp.1" (begin (true)))))
                "expose-pred: succes-6: nested begin")
   
;expose-tail
  ;succes
  (check-expose-func expose-tail '(halt a0) '((halt a0) ()) "expose-tail: succes-.1: halt instruction")
  
  (check-expose-func expose-tail '(begin (set! a0 (+ a1 a2)) (halt a0)) '((begin (set! a0 (+ a1 a2)) (halt a0)) ()) "expose-tail: succes-.2: begin one effect")
  (check-expose-func expose-tail '(begin (set! a0 fv0) (set! a1 fv1) (begin (set! a0 (+ a1 a0)) (set! a2 a0)) (halt a0))
                     '((begin (set! a0 fv0) (set! a1 fv1) (set! a0 (+ a1 a0)) (set! a2 a0) (jump "L.tmp.1"))
                       ((define "L.tmp.1" (begin (halt a0)))))
                     "expose-tail: succes-.3: nested begin")
  (check-expose-func expose-tail '(begin (set! a0 fv0) (set! a1 fv1) (begin (set! a0 (+ a1 a0)) (set! a2 a0) (halt a0)))
                     '((begin (set! a0 fv0) (set! a1 fv1) (begin (set! a0 (+ a1 a0)) (set! a2 a0) (halt a0)))
                       ())
                     "expose-tail: succes-04: nested begin")
  
  (check-expose-func expose-tail '(if (true) (halt a0) (halt a1))
                     '((if (true) (jump "L.tmp.1") (jump "L.tmp.2"))
                       ((define "L.tmp.1" (halt a0)) (define "L.tmp.2" (halt a1))))
                     "expose-tail: succes-05: if single pred")
  (check-expose-func expose-tail '(if (if (= a0 a1) (true) (false)) (halt a0) (halt a1))
                     '((if (= a0 a1) (jump "L.tmp.1") (jump "L.tmp.2"))
                       ((define "L.tmp.1" (if (true) (jump "L.tmp.3") (jump "L.tmp.4")))
                        (define "L.tmp.2" (if (false) (jump "L.tmp.3") (jump "L.tmp.4")))
                        (define "L.tmp.3" (halt a0))
                        (define "L.tmp.4" (halt a1))))
                     "expose-tail: succes-06: if if pred")
  (check-expose-func expose-tail '(if (begin (set! a0 a1) (true)) (halt a0) (halt a1))
                     '((begin (set! a0 a1) (if (true) (jump "L.tmp.1") (jump "L.tmp.2"))
                       ((define "L.tmp.1" (halt a0)) (define "L.tmp.2" (halt a1)))))
                     "expose-tail: succes-07: if begin pred")
;expose-basic-blocks
  ;succes
  (check-expose (expose-basic-blocks '(module (halt a0)))
                '(module (define "L.tmp.1" (halt a0)))
                "expose-basic-blocks: succes-01: halt tail")
  (check-expose (expose-basic-blocks '(module (if (< a0 a1) (halt a0) (halt a1))))
                '(module (define "L.tmp.1" (if (< a0 a1) (jump "L.tmp.2") (jump "L.tmp.3")))
                   (define "L.tmp.2" (halt a0))
                   (define "L.tmp.3" (halt a1)))
                "expose-basic-blocks: succes-02: if tail")
  (check-expose (expose-basic-blocks '(module (if (< a0 a1) (halt a0) (if (= a0 a1) (halt a1) (halt a2)))))
                '(module (define "L.tmp.1" (if (< a0 a1) (jump "L.tmp.2") (jump "L.tmp.3")))
                   (define "L.tmp.2" (halt a0))
                   (define "L.tmp.3" (if (= a0 a1) (jump "L.tmp.4") (jump "L.tmp.5")))
                   (define "L.tmp.4" (halt a1))
                   (define "L.tmp.5" (halt a2)))
                "expose-basic-blocks: succes-03: nested if tail")
  (check-expose (expose-basic-blocks '(module (if (if (< a0 a1) (= a0 a1) (> a0 a1)) (halt a0) (halt a1))))
                '(module (define "L.tmp.1" (if (< a0 a1) (jump "L.tmp.4") (jump "L.tmp.5")))
                   (define "L.tmp.2" (halt a0))           
                   (define "L.tmp.3" (halt a1))
                   (define "L.tmp.4" (if (= a0 a1) (jump "L.tmp.2") (jump "L.tmp.3")))
                   (define "L.tmp.5" (if (> a0 a1) (jump "L.tmp.2") (jump "L.tmp.3"))))
                "expose-basic-blocks: succes-04: nested if tail")
  (check-expose (expose-basic-blocks '(module (if (if (< a0 a1) (= a0 a1) (if (< a0 a1) (= a0 a1) (if (< a0 a1) (= a0 a1) (> a0 a1)))) (halt a0) (halt a1))))
                '(module (define "L.tmp.1" (if (< a0 a1) (jump "L.tmp.4") (jump "L.tmp.5"))) (define "L.tmp.2" (halt a0))
                   (define "L.tmp.3" (halt a1))
                   (define "L.tmp.4" (if (= a0 a1) (jump "L.tmp.2") (jump "L.tmp.3")))
                   (define "L.tmp.5" (if (< a0 a1) (jump "L.tmp.6") (jump "L.tmp.7")))
                   (define "L.tmp.6" (if (= a0 a1) (jump "L.tmp.2") (jump "L.tmp.3")))
                   (define "L.tmp.7" (if (< a0 a1) (jump "L.tmp.8") (jump "L.tmp.9")))
                   (define "L.tmp.8" (if (= a0 a1) (jump "L.tmp.2") (jump "L.tmp.3")))
                   (define "L.tmp.9" (if (> a0 a1) (jump "L.tmp.2") (jump "L.tmp.3"))))
                "expose-basic-blocks: succes-05: multiple nested if pred if tail")
  (check-expose (expose-basic-blocks '(module (if (if (if (< a0 a1) (= a0 a1) (= a1 a0)) (>= a2 a3) (if (< a0 a1) (> a0 a1) (if (<= a0 a1) (!= a0 a1) (>= a0 a1)))) (halt a0) (halt a1))))
                '(module (define "L.tmp.1" (if (< a0 a1) (jump "L.tmp.6") (jump "L.tmp.7")))
                   (define "L.tmp.2" (halt a0))
                   (define "L.tmp.3" (halt a1))
                   (define "L.tmp.4" (if (>= a2 a3) (jump "L.tmp.2") (jump "L.tmp.3")))
                   (define "L.tmp.5" (if (< a0 a1) (jump "L.tmp.8") (jump "L.tmp.9")))
                   (define "L.tmp.6" (if (= a0 a1) (jump "L.tmp.4") (jump "L.tmp.5")))
                   (define "L.tmp.7" (if (= a1 a0) (jump "L.tmp.4") (jump "L.tmp.5")))
                   (define "L.tmp.8" (if (> a0 a1) (jump "L.tmp.2") (jump "L.tmp.3")))
                   (define "L.tmp.9" (if (<= a0 a1) (jump "L.tmp.10") (jump "L.tmp.11")))
                   (define "L.tmp.10" (if (!= a0 a1) (jump "L.tmp.2") (jump "L.tmp.3")))
                   (define "L.tmp.11" (if (>= a0 a1) (jump "L.tmp.2") (jump "L.tmp.3"))))
                "expose-basic-blocks: succes-06: multiple nested if tail")
  (check-expose (expose-basic-blocks '(module (begin (set! a0 b0) (set! a0 b0) (if (if (< a0 a1) (= a0 a1) (= a1 a0)) (halt a0) (halt a1)))))
                '(module (define "L.tmp.1" (begin (set! a0 b0) (set! a0 b0) (if (< a0 a1) (jump "L.tmp.4") (jump "L.tmp.5")))) (define "L.tmp.2" (halt a0))
                   (define "L.tmp.3" (halt a1))
                   (define "L.tmp.4" (if (= a0 a1) (jump "L.tmp.2") (jump "L.tmp.3")))
                   (define "L.tmp.5" (if (= a1 a0) (jump "L.tmp.2") (jump "L.tmp.3"))))
                "expose-basic-blocks: succes-07: begin tail")
  (check-expose (expose-basic-blocks '(module (begin (set! a2 b2) (if (> a0 a1) (set! a0 b0) (set! a1 b1)) (set! a2 b2) (if (if (< a0 a1) (= a0 a1) (= a1 a0)) (halt a0) (halt a1)))))
                '(module (define "L.tmp.1" (begin (set! a2 b2) (if (> a0 a1) (jump "L.tmp.6") (jump "L.tmp.7")))) (define "L.tmp.6" (begin (set! a0 b0) (jump "L.tmp.8")))
                   (define "L.tmp.7" (begin (set! a1 b1) (jump "L.tmp.8")))
                   (define "L.tmp.8" (begin (set! a2 b2) (if (< a0 a1) (jump "L.tmp.4") (jump "L.tmp.5"))))
                   (define "L.tmp.2" (halt a0))
                   (define "L.tmp.3" (halt a1))
                   (define "L.tmp.4" (if (= a0 a1) (jump "L.tmp.2") (jump "L.tmp.3")))
                   (define "L.tmp.5" (if (= a1 a0) (jump "L.tmp.2") (jump "L.tmp.3"))))
                "expose-basic-blocks: succes-08: begin tail if effect")
  (check-expose (expose-basic-blocks '(module (begin (set! a2 b2) (if (if (< a0 a1) (= a0 a1) (= a1 a0)) (set! a0 b0) (set! a1 b1)) (set! a2 b2) (halt a0))))
                '(module (define "L.tmp.1" (begin (set! a2 b2) (if (< a0 a1) (jump "L.tmp.5") (jump "L.tmp.6"))))
                   (define "L.tmp.2" (begin (set! a0 b0) (jump "L.tmp.4")))
                   (define "L.tmp.3" (begin (set! a1 b1) (jump "L.tmp.4")))
                   (define "L.tmp.4" (begin (set! a2 b2) (halt a0)))
                   (define "L.tmp.5" (if (= a0 a1) (jump "L.tmp.2") (jump "L.tmp.3")))
                   (define "L.tmp.6" (if (= a1 a0) (jump "L.tmp.2") (jump "L.tmp.3"))))
                "expose-basic-blocks: succes-09: begin tail if effect with if pred")
  (check-expose (expose-basic-blocks '(module (if (begin (set! a c) (set! c a) (< a0 a1)) (halt a0) (halt a1))))
                '(module (define "L.tmp.1" (begin (set! a c) (set! c a) (if (< a0 a1) (jump "L.tmp.2") (jump "L.tmp.3"))))
                   (define "L.tmp.2" (halt a0))
                   (define "L.tmp.3" (halt a1)))
                "expose-basic-blocks: succes-10: begin pred in if tail")
  (check-expose (expose-basic-blocks '(module (begin (set! a b) (set! c d) (begin (set! e f) (set! k l)) (halt a0))))
                '(module (define "L.tmp.1" (begin (set! a b) (set! c d) (set! e f) (set! k l) (halt a0))))
                 "expose-basic-blocks: succes-11: begin effect in begin tail")
  (check-expose (expose-basic-blocks '(module (begin (set! a b) (set! c d) (begin (set! e f) (begin (set! l f) (set! m l)) (set! k l)) (halt a0))))
                '(module (define "L.tmp.1" (begin (set! a b) (set! c d) (set! e f) (set! l f) (set! m l) (set! k l) (halt a0))))
                "expose-basic-blocks: succes-12: nested begin effect in begin tail")
  ;|#
  )


